<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF Book Reader</title>
    <style>
        /* Page flip animation */
        .page-flip-animation {
            position: relative;
            perspective: 2000px;
        }

        .page-flip-animation::before {
            content: '';
            position: absolute;
            top: 0;
            right: 0;
            bottom: 0;
            left: 0;
            background: rgba(0, 0, 0, 0.1);
            z-index: 10;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .page-flip-animation.left::before {
            background: linear-gradient(to right, rgba(0, 0, 0, 0.1) 0%, transparent 100%);
            animation: pageTurnLeft 0.6s ease-in-out;
        }

        .page-flip-animation.right::before {
            background: linear-gradient(to left, rgba(0, 0, 0, 0.1) 0%, transparent 100%);
            animation: pageTurnRight 0.6s ease-in-out;
        }

        @keyframes pageTurnLeft {
            0% {
                opacity: 0;
                transform: perspective(2000px) rotateY(0deg);
            }
            50% {
                opacity: 0.8;
                transform: perspective(2000px) rotateY(-20deg);
                box-shadow: -15px 0 30px rgba(0, 0, 0, 0.2);
            }
            100% {
                opacity: 0;
                transform: perspective(2000px) rotateY(0deg);
            }
        }

        @keyframes pageTurnRight {
            0% {
                opacity: 0;
                transform: perspective(2000px) rotateY(0deg);
            }
            50% {
                opacity: 0.8;
                transform: perspective(2000px) rotateY(20deg);
                box-shadow: 15px 0 30px rgba(0, 0, 0, 0.2);
            }
            100% {
                opacity: 0;
                transform: perspective(2000px) rotateY(0deg);
            }
        }

        /* Existing styles... */
        @keyframes pageFlip {
            0% {
                transform: perspective(600px) rotateY(0deg);
                box-shadow: 0 0 10px var(--shadow-color);
            }
            50% {
                transform: perspective(600px) rotateY(-30deg) scale(0.98);
                box-shadow: 0 10px 30px var(--shadow-color);
            }
            100% {
                transform: perspective(600px) rotateY(0deg);
                box-shadow: 0 0 10px var(--shadow-color);
            }
        }

        .page-flip {
            animation: pageFlip 0.5s;
        }

        :root {
            --primary-color: #4285f4;
            --secondary-color: #34a853;
            --accent-color: #ea4335;
            --text-color: #333;
            --bg-color: #f5f5f5;
            --sidebar-bg: #ffffff;
            --card-bg: #ffffff;
            --border-color: #e0e0e0;
            --shadow-color: rgba(0, 0, 0, 0.1);
            --highlight-color: rgba(255, 255, 0, 0.3);
            --note-color: #fff9c4;
        }

        [data-theme="dark"] {
            --primary-color: #8ab4f8;
            --secondary-color: #81c995;
            --accent-color: #f28b82;
            --text-color: #e0e0e0;
            --bg-color: #121212;
            --sidebar-bg: #1e1e1e;
            --card-bg: #2d2d2d;
            --border-color: #444;
            --shadow-color: rgba(0, 0, 0, 0.3);
            --highlight-color: rgba(255, 215, 0, 0.3);
            --note-color: #424242;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            transition: background-color 0.3s, color 0.3s, border-color 0.3s;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: var(--text-color);
            background-color: var(--bg-color);
            line-height: 1.6;
        }

        .app-container {
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }

        .app-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem;
            background-color: var(--primary-color);
            color: white;
            box-shadow: 0 2px 5px var(--shadow-color);
        }

        .header-controls {
            display: flex;
            gap: 0.5rem;
        }

        .main-content {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .sidebar {
            width: 300px;
            background-color: var(--sidebar-bg);
            border-right: 1px solid var(--border-color);
            padding: 1rem;
            overflow-y: auto;
            height: calc(100vh - 60px);
        }

        .sidebar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .reader-view {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .reader-view.hidden {
            display: none;
        }

        .reader-toolbar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 1rem;
            background-color: var(--sidebar-bg);
            border-bottom: 1px solid var(--border-color);
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .page-controls, .zoom-controls, .reader-features {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .reader-content {
            display: flex;
            flex: 1;
            overflow: hidden;
            position: relative;
        }

        .feature-sidebar {
            width: 250px;
            background-color: var(--sidebar-bg);
            border-right: 1px solid var(--border-color);
            padding: 1rem;
            overflow-y: auto;
            position: absolute;
            top: 0;
            bottom: 0;
            left: 0;
            z-index: 10;
            transform: translateX(-100%);
            transition: transform 0.3s ease;
        }

        .feature-sidebar.visible {
            transform: translateX(0);
        }

        .pdf-container {
            flex: 1;
            overflow: auto;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 1rem;
            position: relative;
        }

        #pdf-canvas {
            max-width: 100%;
            box-shadow: 0 0 10px var(--shadow-color);
            background-color: white;
            transition: transform 0.3s ease;
        }

        .annotation-layer {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
        }

        .highlight-toolbar {
            position: fixed;
            background-color: var(--card-bg);
            padding: 0.5rem;
            border-radius: 4px;
            box-shadow: 0 2px 5px var(--shadow-color);
            z-index: 100;
            display: flex;
            gap: 0.5rem;
        }

        .highlight-toolbar.hidden {
            display: none;
        }

        .pdf-list {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            margin-top: 1rem;
        }

        .pdf-card {
            background-color: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 0.75rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .pdf-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 2px 5px var(--shadow-color);
        }

        .pdf-card .pdf-actions {
            display: flex;
            gap: 0.5rem;
        }

        .toc-item, .bookmark-item {
            padding: 0.5rem;
            border-radius: 4px;
            cursor: pointer;
            margin-bottom: 0.25rem;
        }

        .toc-item:hover, .bookmark-item:hover {
            background-color: var(--highlight-color);
        }

        .search-results {
            margin-top: 1rem;
        }

        .search-result-item {
            padding: 0.5rem;
            border-bottom: 1px solid var(--border-color);
            cursor: pointer;
        }

        .search-result-item:hover {
            background-color: var(--highlight-color);
        }

        .btn {
            padding: 0.5rem 0.75rem;
            border: none;
            border-radius: 4px;
            background-color: var(--primary-color);
            color: white;
            cursor: pointer;
            font-size: 1rem;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s, transform 0.2s;
        }

        .btn:hover {
            background-color: var(--secondary-color);
            transform: translateY(-1px);
        }

        .btn:active {
            transform: translateY(0);
        }

        .close-btn {
            background-color: transparent;
            color: var(--text-color);
            font-size: 1.5rem;
            padding: 0 0.5rem;
        }

        .close-btn:hover {
            background-color: transparent;
            color: var(--accent-color);
            transform: none;
        }

        .file-input {
            display: none;
        }

        .upload-btn {
            width: 100%;
            margin-bottom: 1rem;
        }

        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: white;
        }

        .loading-overlay.hidden {
            display: none;
        }

        .loading-spinner {
            border: 5px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top: 5px solid white;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin-bottom: 1rem;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .highlight {
            background-color: var(--highlight-color);
            cursor: pointer;
        }

        .note {
            background-color: var(--note-color);
            padding: 0.25rem;
            border-radius: 4px;
            margin-top: 0.5rem;
            font-size: 0.9rem;
        }

        /* Responsive styles */
        @media (max-width: 768px) {
            .sidebar {
                width: 100%;
                position: fixed;
                z-index: 20;
                height: 100vh;
                transform: translateX(-100%);
                transition: transform 0.3s ease;
            }
            
            .sidebar.visible {
                transform: translateX(0);
            }
            
            .reader-toolbar {
                flex-direction: column;
                align-items: stretch;
                gap: 0.5rem;
            }
            
            .page-controls, .zoom-controls, .reader-features {
                justify-content: center;
            }
            
            .feature-sidebar {
                width: 80%;
            }
        }

        @media (max-width: 480px) {
            .app-header h1 {
                font-size: 1.25rem;
            }
            
            .btn {
                padding: 0.4rem 0.6rem;
                font-size: 0.9rem;
            }
            
            #page-jump {
                width: 50px;
            }
        }
    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.min.js"></script>
    <!-- Add howler.js for sound effects -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.3/howler.min.js"></script>
</head>
<body>
    <div class="app-container">
        <header class="app-header">
            <h1>PDF Book Reader</h1>
            <div class="header-controls">
                <button id="theme-toggle" class="btn" aria-label="Toggle dark mode">🌓</button>
                <button id="library-toggle" class="btn" aria-label="Toggle library view">📚</button>
            </div>
        </header>

        <div class="main-content">
            <aside id="library-sidebar" class="sidebar">
                <div class="sidebar-header">
                    <h2>Your Library</h2>
                    <button id="close-library" class="btn close-btn" aria-label="Close library">×</button>
                </div>
                
                <div class="upload-section">
                    <input type="file" id="pdf-upload" accept=".pdf" class="file-input">
                    <label for="pdf-upload" class="btn upload-btn">Upload PDF</label>
                </div>
                
                <div id="pdf-list" class="pdf-list">
                    <!-- PDF list will be populated here -->
                </div>
            </aside>

            <main id="reader-view" class="reader-view hidden">
                <div class="reader-toolbar">
                    <button id="back-to-library" class="btn" aria-label="Back to library">← Library</button>
                    
                    <div class="page-controls">
                        <button id="prev-page" class="btn page-flip" aria-label="Previous page">◀</button>
                        <span id="page-num">Page: 1</span>
                        <span id="page-count">of 0</span>
                        <button id="next-page" class="btn page-flip" aria-label="Next page">▶</button>
                        <input type="number" id="page-jump" min="1" value="1" aria-label="Page number">
                        <button id="go-to-page" class="btn">Go</button>
                    </div>
                    
                    <div class="zoom-controls">
                        <button id="zoom-out" class="btn" aria-label="Zoom out">-</button>
                        <span id="zoom-level">100%</span>
                        <button id="zoom-in" class="btn" aria-label="Zoom in">+</button>
                        <button id="fit-to-page" class="btn" aria-label="Fit to page">Fit</button>
                    </div>
                    
                    <div class="reader-features">
                        <button id="add-bookmark" class="btn" aria-label="Add bookmark">🔖</button>
                        <button id="toggle-toc" class="btn" aria-label="Table of contents">📑</button>
                        <button id="toggle-search" class="btn" aria-label="Search">🔍</button>
                        <button id="fullscreen" class="btn" aria-label="Toggle fullscreen">⛶</button>
                    </div>
                </div>
                
                <div class="reader-content">
                    <aside id="toc-sidebar" class="feature-sidebar hidden">
                        <div class="sidebar-header">
                            <h3>Table of Contents</h3>
                            <button id="close-toc" class="btn close-btn" aria-label="Close table of contents">×</button>
                        </div>
                        <ul id="toc-list"></ul>
                    </aside>
                    
                    <aside id="bookmarks-sidebar" class="feature-sidebar hidden">
                        <div class="sidebar-header">
                            <h3>Bookmarks</h3>
                            <button id="close-bookmarks" class="btn close-btn" aria-label="Close bookmarks">×</button>
                        </div>
                        <ul id="bookmarks-list"></ul>
                    </aside>
                    
                    <aside id="search-sidebar" class="feature-sidebar hidden">
                        <div class="sidebar-header">
                            <h3>Search</h3>
                            <button id="close-search" class="btn close-btn" aria-label="Close search">×</button>
                        </div>
                        <div class="search-controls">
                            <input type="text" id="search-input" placeholder="Search text..." aria-label="Search text">
                            <button id="search-btn" class="btn">Search</button>
                        </div>
                        <div id="search-results" class="search-results"></div>
                    </aside>
                    
                    <div class="pdf-container" id="pdf-container">
                        <canvas id="pdf-canvas"></canvas>
                        <div id="annotation-layer" class="annotation-layer"></div>
                    </div>
                    
                    <div id="highlight-toolbar" class="highlight-toolbar hidden">
                        <button id="add-highlight" class="btn highlight-btn">Highlight</button>
                        <button id="add-note" class="btn highlight-btn">Add Note</button>
                        <button id="cancel-highlight" class="btn highlight-btn">Cancel</button>
                    </div>
                </div>
            </main>
        </div>
    </div>

    <div id="loading-overlay" class="loading-overlay hidden">
        <div class="loading-spinner"></div>
        <p id="loading-text">Loading PDF...</p>
    </div>

    <script>
        // Initialize PDF.js
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.worker.min.js';

        // Initialize sound effects
        const pageFlipSound = new Howl({
            src: ['https://assets.mixkit.co/sfx/preview/mixkit-page-turn-book-1211.mp3'],
            volume: 0.5
        });

        // DOM Elements
        const pdfUpload = document.getElementById('pdf-upload');
        const pdfList = document.getElementById('pdf-list');
        const readerView = document.getElementById('reader-view');
        const pdfCanvas = document.getElementById('pdf-canvas');
        const pdfContainer = document.getElementById('pdf-container');
        const annotationLayer = document.getElementById('annotation-layer');
        const pageNum = document.getElementById('page-num');
        const pageCount = document.getElementById('page-count');
        const prevPage = document.getElementById('prev-page');
        const nextPage = document.getElementById('next-page');
        const pageJump = document.getElementById('page-jump');
        const goToPage = document.getElementById('go-to-page');
        const zoomIn = document.getElementById('zoom-in');
        const zoomOut = document.getElementById('zoom-out');
        const zoomLevel = document.getElementById('zoom-level');
        const fitToPage = document.getElementById('fit-to-page');
        const addBookmark = document.getElementById('add-bookmark');
        const toggleToc = document.getElementById('toggle-toc');
        const toggleSearch = document.getElementById('toggle-search');
        const fullscreen = document.getElementById('fullscreen');
        const tocSidebar = document.getElementById('toc-sidebar');
        const tocList = document.getElementById('toc-list');
        const bookmarksSidebar = document.getElementById('bookmarks-sidebar');
        const bookmarksList = document.getElementById('bookmarks-list');
        const searchSidebar = document.getElementById('search-sidebar');
        const searchInput = document.getElementById('search-input');
        const searchBtn = document.getElementById('search-btn');
        const searchResults = document.getElementById('search-results');
        const highlightToolbar = document.getElementById('highlight-toolbar');
        const addHighlight = document.getElementById('add-highlight');
        const addNote = document.getElementById('add-note');
        const cancelHighlight = document.getElementById('cancel-highlight');
        const themeToggle = document.getElementById('theme-toggle');
        const libraryToggle = document.getElementById('library-toggle');
        const librarySidebar = document.getElementById('library-sidebar');
        const closeLibrary = document.getElementById('close-library');
        const backToLibrary = document.getElementById('back-to-library');
        const loadingOverlay = document.getElementById('loading-overlay');
        const loadingText = document.getElementById('loading-text');

        // App State
        let currentPdf = null;
        let currentPage = 1;
        let pdfDoc = null;
        let scale = 1.0;
        let isDarkMode = false;
        let selectedText = '';
        let selectionRect = null;
        let highlights = {};
        let notes = {};
        let bookmarks = [];
        let currentPdfId = null;
        let searchQuery = '';
        let searchMatches = [];
        let currentSearchIndex = -1;
        let isAnimating = false;

        // Initialize the app
        function initApp() {
            loadThemePreference();
            setupEventListeners();
            initIndexedDB().then(() => {
                loadPdfList();
            });
        }

        // Set up event listeners
        function setupEventListeners() {
            // PDF Upload
            pdfUpload.addEventListener('change', handlePdfUpload);
            
            // Page Navigation
            prevPage.addEventListener('click', goToPrevPage);
            nextPage.addEventListener('click', goToNextPage);
            goToPage.addEventListener('click', jumpToPage);
            pageJump.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') jumpToPage();
            });
            
            // Zoom Controls
            zoomIn.addEventListener('click', () => adjustZoom(0.1));
            zoomOut.addEventListener('click', () => adjustZoom(-0.1));
            fitToPage.addEventListener('click', fitPageToView);
            
            // Reader Features
            addBookmark.addEventListener('click', addCurrentBookmark);
            toggleToc.addEventListener('click', toggleTocSidebar);
            toggleSearch.addEventListener('click', toggleSearchSidebar);
            fullscreen.addEventListener('click', toggleFullscreen);
            
            // Sidebar Controls
            closeLibrary.addEventListener('click', closeLibrarySidebar);
            backToLibrary.addEventListener('click', showLibraryView);
            libraryToggle.addEventListener('click', toggleLibrarySidebar);
            
            // Theme Toggle
            themeToggle.addEventListener('click', toggleTheme);
            
            // Text Selection
            document.addEventListener('mouseup', handleTextSelection);
            document.addEventListener('mousedown', clearSelection);
            
            // Highlight Controls
            addHighlight.addEventListener('click', saveHighlight);
            addNote.addEventListener('click', showNoteDialog);
            cancelHighlight.addEventListener('click', cancelHighlightSelection);
            
            // Search
            searchBtn.addEventListener('click', performSearch);
            searchInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') performSearch();
            });
            
            // Fullscreen change
            document.addEventListener('fullscreenchange', handleFullscreenChange);
            
            // Window resize
            window.addEventListener('resize', debounce(handleResize, 200));
        }

        // Initialize IndexedDB
        let db;

        function initIndexedDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open('PDFReaderDB', 1);
                
                request.onerror = (event) => {
                    console.error('Database error:', event.target.error);
                    reject('Database error');
                };
                
                request.onupgradeneeded = (event) => {
                    const dbInstance = event.target.result;
                    
                    if (!dbInstance.objectStoreNames.contains('pdfs')) {
                        dbInstance.createObjectStore('pdfs', { keyPath: 'id' });
                    }
                    
                    if (!dbInstance.objectStoreNames.contains('bookmarks')) {
                        const store = dbInstance.createObjectStore('bookmarks', { keyPath: 'id' });
                        store.createIndex('pdfId', 'pdfId', { unique: false });
                    }
                    
                    if (!dbInstance.objectStoreNames.contains('annotations')) {
                        const store = dbInstance.createObjectStore('annotations', { keyPath: 'id' });
                        store.createIndex('pdfId', 'pdfId', { unique: false });
                    }
                };
                
                request.onsuccess = (event) => {
                    db = event.target.result;
                    resolve();
                };
            });
        }

        // Load PDF list from IndexedDB
        function loadPdfList() {
            const transaction = db.transaction(['pdfs'], 'readonly');
            const store = transaction.objectStore('pdfs');
            const request = store.getAll();
            
            request.onsuccess = (event) => {
                const pdfs = event.target.result;
                renderPdfList(pdfs);
            };
            
            request.onerror = (event) => {
                console.error('Error loading PDF list:', event.target.error);
            };
        }

        // Render PDF list
        function renderPdfList(pdfs) {
            pdfList.innerHTML = '';
            
            if (pdfs.length === 0) {
                pdfList.innerHTML = '<p class="empty-message">No PDFs uploaded yet.</p>';
                return;
            }
            
            pdfs.forEach(pdf => {
                const pdfCard = document.createElement('div');
                pdfCard.className = 'pdf-card';
                pdfCard.innerHTML = `
                    <span>${pdf.name}</span>
                    <div class="pdf-actions">
                        <button class="btn open-pdf" data-id="${pdf.id}">Open</button>
                        <button class="btn delete-pdf" data-id="${pdf.id}">Delete</button>
                    </div>
                `;
                pdfList.appendChild(pdfCard);
            });
            
            // Add event listeners to the buttons
            document.querySelectorAll('.open-pdf').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const pdfId = e.target.getAttribute('data-id');
                    openPdf(pdfId);
                });
            });
            
            document.querySelectorAll('.delete-pdf').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const pdfId = e.target.getAttribute('data-id');
                    deletePdf(pdfId);
                });
            });
        }

        // Handle PDF upload
        function handlePdfUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            showLoading(`Uploading ${file.name}...`);
            
            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    const pdfId = generateId();
                    const pdfName = file.name;

                    // Read as ArrayBuffer for PDF.js compatibility
                    const arrayBufferReader = new FileReader();
                    arrayBufferReader.onload = async (ev) => {
                        const pdfData = ev.target.result;

                        // Validate PDF
                        try {
                            const loadingTask = pdfjsLib.getDocument({ data: pdfData });
                            await loadingTask.promise;
                        } catch (error) {
                            hideLoading();
                            alert('Invalid PDF file. Please upload a valid PDF.');
                            return;
                        }

                        // Store PDF in IndexedDB
                        const transaction = db.transaction(['pdfs'], 'readwrite');
                        const store = transaction.objectStore('pdfs');

                        store.add({
                            id: pdfId,
                            name: pdfName,
                            data: pdfData,
                            uploadedAt: new Date().toISOString()
                        });

                        transaction.oncomplete = () => {
                            hideLoading();
                            loadPdfList();
                            event.target.value = ''; // Clear the input
                        };

                        transaction.onerror = (event) => {
                            hideLoading();
                            console.error('Error saving PDF:', event.target.error);
                            alert('Error saving PDF. Please try again.');
                        };
                    };
                    arrayBufferReader.onerror = () => {
                        hideLoading();
                        alert('Error reading file. Please try again.');
                    };
                    arrayBufferReader.readAsArrayBuffer(file);
                    return;
                } catch (error) {
                    hideLoading();
                    console.error('Error processing PDF:', error);
                    alert('Error processing PDF. Please try again.');
                }
            };
            
            reader.onerror = () => {
                hideLoading();
                alert('Error reading file. Please try again.');
            };
            
            reader.readAsDataURL(file);
        }

        // Open PDF
        function openPdf(pdfId) {
            showLoading('Loading PDF...');
            
            const transaction = db.transaction(['pdfs'], 'readonly');
            const store = transaction.objectStore('pdfs');
            const request = store.get(pdfId);
            
            request.onsuccess = async (event) => {
                const pdf = event.target.result;
                if (!pdf) {
                    hideLoading();
                    alert('PDF not found.');
                    return;
                }
                
                currentPdfId = pdfId;
                currentPdf = pdf;
                
                try {
                    const loadingTask = pdfjsLib.getDocument({ data: pdf.data });
                    pdfDoc = await loadingTask.promise;
                    
                    // Load bookmarks and annotations
                    await loadBookmarks();
                    await loadAnnotations();
                    
                    // Render the first page
                    currentPage = 1;
                    pageCount.textContent = `of ${pdfDoc.numPages}`;
                    renderPage(currentPage);
                    
                    // Try to extract TOC
                    extractToc();
                    
                    // Switch to reader view
                    showReaderView();
                    hideLoading();
                } catch (error) {
                    hideLoading();
                    console.error('Error loading PDF:', error);
                    alert('Error loading PDF. Please try again.');
                }
            };
            
            request.onerror = (event) => {
                hideLoading();
                console.error('Error loading PDF:', event.target.error);
                alert('Error loading PDF. Please try again.');
            };
        }

        // Delete PDF
        function deletePdf(pdfId) {
            if (!confirm('Are you sure you want to delete this PDF?')) return;
            
            // Start transactions for all related data
            const pdfTransaction = db.transaction(['pdfs'], 'readwrite');
            const pdfStore = pdfTransaction.objectStore('pdfs');
            
            const bookmarkTransaction = db.transaction(['bookmarks'], 'readwrite');
            const bookmarkStore = bookmarkTransaction.objectStore('bookmarks');
            const bookmarkIndex = bookmarkStore.index('pdfId');
            
            const annotationTransaction = db.transaction(['annotations'], 'readwrite');
            const annotationStore = annotationTransaction.objectStore('annotations');
            const annotationIndex = annotationStore.index('pdfId');
            
            // Delete the PDF
            pdfStore.delete(pdfId);
            
            // Delete all bookmarks for this PDF
            bookmarkIndex.openCursor(IDBKeyRange.only(pdfId)).onsuccess = function(event) {
                const cursor = event.target.result;
                if (cursor) {
                    bookmarkStore.delete(cursor.primaryKey);
                    cursor.continue();
                }
            };
            
            // Delete all annotations for this PDF
            annotationIndex.openCursor(IDBKeyRange.only(pdfId)).onsuccess = function(event) {
                const cursor = event.target.result;
                if (cursor) {
                    annotationStore.delete(cursor.primaryKey);
                    cursor.continue();
                }
            };
            
            pdfTransaction.oncomplete = () => {
                // If we're currently viewing the deleted PDF, go back to library
                if (currentPdfId === pdfId) {
                    showLibraryView();
                }
                loadPdfList();
            };
        }

        // Render PDF page with animation
        async function renderPage(pageNum, direction = null) {
            if (!pdfDoc || isAnimating) return;
            
            try {
                isAnimating = true;
                
                // Play page flip sound
                pageFlipSound.play();
                
                // Add animation class based on direction
                if (direction) {
                    pdfContainer.classList.add('page-flip-animation', direction);
                    
                    // Remove animation classes after animation completes
                    setTimeout(() => {
                        pdfContainer.classList.remove('page-flip-animation', direction);
                        isAnimating = false;
                    }, 600);
                } else {
                    isAnimating = false;
                }
                
                const page = await pdfDoc.getPage(pageNum);
                const viewport = page.getViewport({ scale: scale });
                
                // Set canvas dimensions
                pdfCanvas.height = viewport.height;
                pdfCanvas.width = viewport.width;
                
                // Render PDF page
                const renderContext = {
                    canvasContext: pdfCanvas.getContext('2d'),
                    viewport: viewport
                };
                
                await page.render(renderContext).promise;
                
                // Update page display
                updatePageDisplay(pageNum);
                
                // Render annotations
                renderAnnotations(pageNum);
            } catch (error) {
                console.error('Error rendering page:', error);
                isAnimating = false;
            }
        }

        // Update page display
        function updatePageDisplay(pageNum) {
            currentPage = pageNum;
            pageNum.textContent = `Page: ${pageNum}`;
            pageJump.value = pageNum;
            
            // Update bookmark button state
            const isBookmarked = bookmarks.some(b => b.page === pageNum);
            addBookmark.textContent = isBookmarked ? '🔖✓' : '🔖';
            
            // Update URL hash for deep linking
            if (currentPdfId) {
                window.location.hash = `#pdf=${currentPdfId}&page=${pageNum}`;
            }
        }

        // Page navigation with animations
        function goToPrevPage() {
            if (currentPage > 1 && !isAnimating) {
                currentPage--;
                renderPage(currentPage, 'right'); // Animate right for previous page
            }
        }

        function goToNextPage() {
            if (currentPage < pdfDoc.numPages && !isAnimating) {
                currentPage++;
                renderPage(currentPage, 'left'); // Animate left for next page
            }
        }

        function jumpToPage() {
            const pageNumber = parseInt(pageJump.value);
            if (pageNumber >= 1 && pageNumber <= pdfDoc.numPages && !isAnimating) {
                const direction = pageNumber > currentPage ? 'left' : 'right';
                currentPage = pageNumber;
                renderPage(currentPage, direction);
            } else if (!isAnimating) {
                alert(`Please enter a page number between 1 and ${pdfDoc.numPages}`);
            }
        }

        // Zoom controls
        function adjustZoom(zoomDelta) {
            scale += zoomDelta;
            scale = Math.max(0.5, Math.min(scale, 3.0)); // Limit zoom range
            zoomLevel.textContent = `${Math.round(scale * 100)}%`;
            renderPage(currentPage);
        }

        function fitPageToView() {
            if (!pdfDoc || !pdfCanvas.parentElement || isAnimating) return;
            
            const container = pdfCanvas.parentElement;
            const containerWidth = container.clientWidth - 40; // Account for padding
            const containerHeight = container.clientHeight - 40;
            
            pdfDoc.getPage(currentPage).then(page => {
                const viewport = page.getViewport({ scale: 1.0 });
                const scaleX = containerWidth / viewport.width;
                const scaleY = containerHeight / viewport.height;
                scale = Math.min(scaleX, scaleY);
                zoomLevel.textContent = `${Math.round(scale * 100)}%`;
                renderPage(currentPage);
            });
        }

        // Bookmark functions
        async function loadBookmarks() {
            if (!currentPdfId) return;
            
            return new Promise((resolve) => {
                const transaction = db.transaction(['bookmarks'], 'readonly');
                const store = transaction.objectStore('bookmarks');
                const index = store.index('pdfId');
                const request = index.getAll(IDBKeyRange.only(currentPdfId));
                
                request.onsuccess = (event) => {
                    bookmarks = event.target.result || [];
                    renderBookmarksList();
                    resolve();
                };
                
                request.onerror = (event) => {
                    console.error('Error loading bookmarks:', event.target.error);
                    resolve();
                };
            });
        }

        function renderBookmarksList() {
            bookmarksList.innerHTML = '';
            
            if (bookmarks.length === 0) {
                bookmarksList.innerHTML = '<p class="empty-message">No bookmarks yet.</p>';
                return;
            }
            
            bookmarks.sort((a, b) => a.page - b.page).forEach(bookmark => {
                const bookmarkItem = document.createElement('li');
                bookmarkItem.className = 'bookmark-item';
                bookmarkItem.innerHTML = `
                    <span>Page ${bookmark.page}</span>
                    <button class="btn delete-bookmark" data-id="${bookmark.id}">×</button>
                `;
                bookmarkItem.addEventListener('click', () => {
                    currentPage = bookmark.page;
                    renderPage(currentPage);
                    closeBookmarksSidebar();
                });
                
                const deleteBtn = bookmarkItem.querySelector('.delete-bookmark');
                deleteBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    deleteBookmark(bookmark.id);
                });
                
                bookmarksList.appendChild(bookmarkItem);
            });
        }

        function addCurrentBookmark() {
            if (!currentPdfId || !pdfDoc) return;
            
            const isBookmarked = bookmarks.some(b => b.page === currentPage);
            
            if (isBookmarked) {
                // Remove bookmark
                const bookmark = bookmarks.find(b => b.page === currentPage);
                if (bookmark) {
                    deleteBookmark(bookmark.id);
                }
            } else {
                // Add new bookmark
                const bookmarkId = generateId();
                const bookmark = {
                    id: bookmarkId,
                    pdfId: currentPdfId,
                    page: currentPage,
                    createdAt: new Date().toISOString()
                };
                
                const transaction = db.transaction(['bookmarks'], 'readwrite');
                const store = transaction.objectStore('bookmarks');
                
                store.add(bookmark);
                
                transaction.oncomplete = () => {
                    bookmarks.push(bookmark);
                    renderBookmarksList();
                    updatePageDisplay(currentPage);
                };
                
                transaction.onerror = (event) => {
                    console.error('Error saving bookmark:', event.target.error);
                };
            }
        }

        function deleteBookmark(bookmarkId) {
            const transaction = db.transaction(['bookmarks'], 'readwrite');
            const store = transaction.objectStore('bookmarks');
            
            store.delete(bookmarkId);
            
            transaction.oncomplete = () => {
                bookmarks = bookmarks.filter(b => b.id !== bookmarkId);
                renderBookmarksList();
                updatePageDisplay(currentPage);
            };
            
            transaction.onerror = (event) => {
                console.error('Error deleting bookmark:', event.target.error);
            };
        }

        // Table of Contents
        async function extractToc() {
            if (!pdfDoc) return;
            
            try {
                const metadata = await pdfDoc.getMetadata();
                const outline = await pdfDoc.getOutline();
                
                tocList.innerHTML = '';
                
                if (!outline || outline.length === 0) {
                    tocList.innerHTML = '<p class="empty-message">No table of contents available.</p>';
                    return;
                }
                
                renderTocItems(outline, tocList);
            } catch (error) {
                console.error('Error extracting TOC:', error);
                tocList.innerHTML = '<p class="empty-message">Error loading table of contents.</p>';
            }
        }

        function renderTocItems(items, parentElement) {
            items.forEach(item => {
                const tocItem = document.createElement('li');
                tocItem.className = 'toc-item';
                
                const title = document.createElement('span');
                title.textContent = item.title;
                tocItem.appendChild(title);
                
                if (item.dest) {
                    tocItem.addEventListener('click', async () => {
                        // Handle different types of destinations
                        if (typeof item.dest === 'string') {
                            // Named destination
                            const page = await pdfDoc.getPageIndex(item.dest);
                            if (page >= 0) {
                                currentPage = page + 1;
                                renderPage(currentPage);
                                closeTocSidebar();
                            }
                        } else if (Array.isArray(item.dest)) {
                            // Explicit destination
                            const pageRef = item.dest[0];
                            const page = await pdfDoc.getPageIndex(pageRef);
                            if (page >= 0) {
                                currentPage = page + 1;
                                renderPage(currentPage);
                                closeTocSidebar();
                            }
                        }
                    });
                }
                
                if (item.items && item.items.length > 0) {
                    const subList = document.createElement('ul');
                    renderTocItems(item.items, subList);
                    tocItem.appendChild(subList);
                }
                
                parentElement.appendChild(tocItem);
            });
        }

        // Text selection and annotations
        function handleTextSelection() {
            const selection = window.getSelection();
            if (!selection || selection.isCollapsed || !pdfCanvas.contains(selection.anchorNode)) {
                return;
            }
            
            selectedText = selection.toString().trim();
            if (!selectedText) return;
            
            // Get the bounding rectangle of the selection
            const range = selection.getRangeAt(0);
            const rect = range.getBoundingClientRect();
            
            // Calculate position relative to the PDF canvas
            const canvasRect = pdfCanvas.getBoundingClientRect();
            selectionRect = {
                left: rect.left - canvasRect.left,
                top: rect.top - canvasRect.top,
                width: rect.width,
                height: rect.height,
                text: selectedText
            };
            
            // Position the highlight toolbar
            positionHighlightToolbar(selectionRect);
        }

        function clearSelection() {
            const selection = window.getSelection();
            if (!selection.isCollapsed) {
                selection.removeAllRanges();
            }
            selectedText = '';
            selectionRect = null;
            hideHighlightToolbar();
        }

        function positionHighlightToolbar(rect) {
            highlightToolbar.classList.remove('hidden');
            
            const canvasRect = pdfCanvas.getBoundingClientRect();
            const toolbarWidth = highlightToolbar.offsetWidth;
            const toolbarHeight = highlightToolbar.offsetHeight;
            
            let left = rect.left + (rect.width / 2) - (toolbarWidth / 2);
            let top = rect.top - toolbarHeight - 10;
            
            // Adjust if toolbar would go off screen
            if (left < 0) left = 0;
            if (left + toolbarWidth > canvasRect.width) {
                left = canvasRect.width - toolbarWidth;
            }
            if (top < 0) top = rect.top + rect.height + 10;
            
            highlightToolbar.style.left = `${left}px`;
            highlightToolbar.style.top = `${top}px`;
        }

        function hideHighlightToolbar() {
            highlightToolbar.classList.add('hidden');
        }

        function cancelHighlightSelection() {
            clearSelection();
            hideHighlightToolbar();
        }

        function saveHighlight() {
            if (!currentPdfId || !selectionRect) return;
            
            const highlightId = generateId();
            const highlight = {
                id: highlightId,
                pdfId: currentPdfId,
                page: currentPage,
                text: selectedText,
                rect: selectionRect,
                type: 'highlight',
                createdAt: new Date().toISOString()
            };
            
            const transaction = db.transaction(['annotations'], 'readwrite');
            const store = transaction.objectStore('annotations');
            
            store.add(highlight);
            
            transaction.oncomplete = () => {
                if (!highlights[currentPage]) {
                    highlights[currentPage] = [];
                }
                highlights[currentPage].push(highlight);
                renderAnnotations(currentPage);
                clearSelection();
                hideHighlightToolbar();
            };
            
            transaction.onerror = (event) => {
                console.error('Error saving highlight:', event.target.error);
            };
        }

        function showNoteDialog() {
            if (!currentPdfId || !selectionRect) return;
            
            const noteText = prompt('Enter your note:', '');
            if (noteText === null || noteText.trim() === '') return;
            
            const noteId = generateId();
            const note = {
                id: noteId,
                pdfId: currentPdfId,
                page: currentPage,
                text: selectedText,
                note: noteText,
                rect: selectionRect,
                type: 'note',
                createdAt: new Date().toISOString()
            };
            
            const transaction = db.transaction(['annotations'], 'readwrite');
            const store = transaction.objectStore('annotations');
            
            store.add(note);
            
            transaction.oncomplete = () => {
                if (!notes[currentPage]) {
                    notes[currentPage] = [];
                }
                notes[currentPage].push(note);
                renderAnnotations(currentPage);
                clearSelection();
                hideHighlightToolbar();
            };
            
            transaction.onerror = (event) => {
                console.error('Error saving note:', event.target.error);
            };
        }

        async function loadAnnotations() {
            if (!currentPdfId) return;
            
            return new Promise((resolve) => {
                highlights = {};
                notes = {};
                
                const transaction = db.transaction(['annotations'], 'readonly');
                const store = transaction.objectStore('annotations');
                const index = store.index('pdfId');
                const request = index.getAll(IDBKeyRange.only(currentPdfId));
                
                request.onsuccess = (event) => {
                    const annotations = event.target.result || [];
                    
                    annotations.forEach(annotation => {
                        if (annotation.type === 'highlight') {
                            if (!highlights[annotation.page]) {
                                highlights[annotation.page] = [];
                            }
                            highlights[annotation.page].push(annotation);
                        } else if (annotation.type === 'note') {
                            if (!notes[annotation.page]) {
                                notes[annotation.page] = [];
                            }
                            notes[annotation.page].push(annotation);
                        }
                    });
                    
                    resolve();
                };
                
                request.onerror = (event) => {
                    console.error('Error loading annotations:', event.target.error);
                    resolve();
                };
            });
        }

        function renderAnnotations(pageNum) {
            annotationLayer.innerHTML = '';
            
            // Render highlights
            if (highlights[pageNum]) {
                highlights[pageNum].forEach(highlight => {
                    const highlightEl = document.createElement('div');
                    highlightEl.className = 'highlight';
                    highlightEl.style.left = `${highlight.rect.left}px`;
                    highlightEl.style.top = `${highlight.rect.top}px`;
                    highlightEl.style.width = `${highlight.rect.width}px`;
                    highlightEl.style.height = `${highlight.rect.height}px`;
                    annotationLayer.appendChild(highlightEl);
                });
            }
            
            // Render notes
            if (notes[pageNum]) {
                notes[pageNum].forEach(note => {
                    const noteMarker = document.createElement('div');
                    noteMarker.className = 'highlight';
                    noteMarker.style.left = `${note.rect.left}px`;
                    noteMarker.style.top = `${note.rect.top}px`;
                    noteMarker.style.width = `${note.rect.width}px`;
                    noteMarker.style.height = `${note.rect.height}px`;
                    
                    const noteEl = document.createElement('div');
                    noteEl.className = 'note';
                    noteEl.textContent = note.note;
                    noteEl.style.left = `${note.rect.left + note.rect.width + 5}px`;
                    noteEl.style.top = `${note.rect.top}px`;
                    
                    annotationLayer.appendChild(noteMarker);
                    annotationLayer.appendChild(noteEl);
                });
            }
        }

        // Search functionality
        function performSearch() {
            if (!pdfDoc || !currentPdfId) return;
            
            searchQuery = searchInput.value.trim();
            if (!searchQuery) return;
            
            showLoading('Searching...');
            searchMatches = [];
            currentSearchIndex = -1;
            searchResults.innerHTML = '';
            
            // Search through each page
            const pagePromises = [];
            for (let i = 1; i <= pdfDoc.numPages; i++) {
                pagePromises.push(searchPage(i));
            }
            
            Promise.all(pagePromises).then(() => {
                hideLoading();
                if (searchMatches.length === 0) {
                    searchResults.innerHTML = '<p class="empty-message">No matches found.</p>';
                } else {
                    highlightCurrentSearchMatch();
                }
            }).catch(error => {
                hideLoading();
                console.error('Search error:', error);
                searchResults.innerHTML = '<p class="empty-message">Error during search.</p>';
            });
        }

        async function searchPage(pageNum) {
            try {
                const page = await pdfDoc.getPage(pageNum);
                const textContent = await page.getTextContent();
                
                // Search through text items
                textContent.items.forEach((item, itemIndex) => {
                    if (item.str.includes(searchQuery)) {
                        searchMatches.push({
                            page: pageNum,
                            itemIndex: itemIndex,
                            text: item.str
                        });
                        
                        // Add to search results list
                        const resultItem = document.createElement('div');
                        resultItem.className = 'search-result-item';
                        resultItem.textContent = `Page ${pageNum}: ${item.str.substring(0, 50)}...`;
                        resultItem.addEventListener('click', () => {
                            currentSearchIndex = searchMatches.findIndex(m => 
                                m.page === pageNum && m.itemIndex === itemIndex
                            );
                            navigateToSearchMatch();
                        });
                        searchResults.appendChild(resultItem);
                    }
                });
            } catch (error) {
                console.error(`Error searching page ${pageNum}:`, error);
            }
        }

        function highlightCurrentSearchMatch() {
            if (currentSearchIndex < 0 || currentSearchIndex >= searchMatches.length) return;
            
            const match = searchMatches[currentSearchIndex];
            
            // Navigate to the page if needed
            if (currentPage !== match.page) {
                currentPage = match.page;
                renderPage(currentPage).then(() => {
                    // Need to wait for page render to highlight
                    setTimeout(highlightCurrentSearchMatch, 100);
                });
                return;
            }
            
            // TODO: Implement actual highlighting on the PDF canvas
            // This is complex with PDF.js and would require more advanced rendering
            // For now, we'll just show which result is selected in the list
            
            // Update search results UI
            const resultItems = document.querySelectorAll('.search-result-item');
            resultItems.forEach((item, index) => {
                if (index === currentSearchIndex) {
                    item.style.backgroundColor = 'var(--highlight-color)';
                } else {
                    item.style.backgroundColor = 'transparent';
                }
            });
        }

        function navigateToSearchMatch() {
            if (currentSearchIndex < 0 || currentSearchIndex >= searchMatches.length) return;
            
            const match = searchMatches[currentSearchIndex];
            currentPage = match.page;
            renderPage(currentPage);
            highlightCurrentSearchMatch();
        }

        function nextSearchMatch() {
            if (searchMatches.length === 0) return;
            
            currentSearchIndex = (currentSearchIndex + 1) % searchMatches.length;
            navigateToSearchMatch();
        }

        function prevSearchMatch() {
            if (searchMatches.length === 0) return;
            
            currentSearchIndex = (currentSearchIndex - 1 + searchMatches.length) % searchMatches.length;
            navigateToSearchMatch();
        }

        // View management
        function showLibraryView() {
            librarySidebar.classList.add('visible');
            readerView.classList.add('hidden');
            currentPdf = null;
            currentPdfId = null;
            pdfDoc = null;
            window.location.hash = '';
        }

        function showReaderView() {
            librarySidebar.classList.remove('visible');
            readerView.classList.remove('hidden');
        }

        function toggleLibrarySidebar() {
            librarySidebar.classList.toggle('visible');
        }

        function closeLibrarySidebar() {
            librarySidebar.classList.remove('visible');
        }

        function toggleTocSidebar() {
            tocSidebar.classList.toggle('visible');
            bookmarksSidebar.classList.remove('visible');
            searchSidebar.classList.remove('visible');
        }

        function closeTocSidebar() {
            tocSidebar.classList.remove('visible');
        }

        function toggleBookmarksSidebar() {
            bookmarksSidebar.classList.toggle('visible');
            tocSidebar.classList.remove('visible');
            searchSidebar.classList.remove('visible');
        }

        function closeBookmarksSidebar() {
            bookmarksSidebar.classList.remove('visible');
        }

        function toggleSearchSidebar() {
            searchSidebar.classList.toggle('visible');
            tocSidebar.classList.remove('visible');
            bookmarksSidebar.classList.remove('visible');
            
            if (searchSidebar.classList.contains('visible')) {
                searchInput.focus();
            }
        }

        function closeSearchSidebar() {
            searchSidebar.classList.remove('visible');
        }

        // Fullscreen mode
        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => {
                    console.error('Error attempting to enable fullscreen:', err);
                });
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
            }
        }

        function handleFullscreenChange() {
            if (document.fullscreenElement) {
                fullscreen.textContent = '⛶ Exit';
            } else {
                fullscreen.textContent = '⛶';
            }
        }

        // Theme management
        function loadThemePreference() {
            const savedTheme = localStorage.getItem('theme');
            isDarkMode = savedTheme === 'dark';
            applyTheme();
        }

        function toggleTheme() {
            isDarkMode = !isDarkMode;
            localStorage.setItem('theme', isDarkMode ? 'dark' : 'light');
            applyTheme();
        }

        function applyTheme() {
            if (isDarkMode) {
                document.documentElement.setAttribute('data-theme', 'dark');
                themeToggle.textContent = '☀️';
                
                // Adjust PDF canvas for dark mode
                if (pdfCanvas) {
                    pdfCanvas.style.filter = 'invert(90%) hue-rotate(180deg) brightness(85%) contrast(90%)';
                }
            } else {
                document.documentElement.removeAttribute('data-theme');
                themeToggle.textContent = '🌓';
                
                // Reset PDF canvas
                if (pdfCanvas) {
                    pdfCanvas.style.filter = 'none';
                }
            }
        }
 
        // Loading overlay
        function showLoading(message) {
            loadingText.textContent = message || 'Loading...';
            loadingOverlay.classList.remove('hidden');
        }

        function hideLoading() {
            loadingOverlay.classList.add('hidden');
        }

        // Window resize handler
        function handleResize() {
            if (pdfDoc && currentPage && !isAnimating) {
                renderPage(currentPage);
            }
        }

        // Helper functions
        function generateId() {
            return Date.now().toString(36) + Math.random().toString(36).substr(2);
        }

        function debounce(func, wait) {
            let timeout;
            return function() {
                const context = this, args = arguments;
                clearTimeout(timeout);
                timeout = setTimeout(() => {
                    func.apply(context, args);
                }, wait);
            };
        }

        // Initialize the app when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            // Check for deep link (PDF and page in URL hash)
            const hash = window.location.hash.substr(1);
            const params = new URLSearchParams(hash);
            const pdfId = params.get('pdf');
            const page = params.get('page');
            
            initApp();
            
            // If there's a PDF ID in the URL, try to open it
            if (pdfId) {
                openPdf(pdfId).then(() => {
                    if (page) {
                        currentPage = parseInt(page);
                        renderPage(currentPage);
                    }
                });
            }
        });
    </script>
</body>
</html>